package cmd

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/stuttgart-things/claims/internal/gitops"
	"github.com/stuttgart-things/claims/internal/registry"
)

// executeEncryptGitOperations performs git commit, push, and PR creation for an encrypt operation
func executeEncryptGitOperations(result *EncryptResult, config *EncryptConfig) error {
	if config.GitConfig == nil {
		return nil
	}

	// Resolve credentials
	user, token := config.GitConfig.User, config.GitConfig.Token
	if config.GitConfig.Push {
		var err error
		user, token, err = gitops.ResolveCredentials(user, token)
		if err != nil {
			return err
		}
	} else {
		user, token = gitops.ResolveCredentialsOptional(user, token)
	}

	// Find repo root from output path
	repoRoot, err := findRepoRoot(filepath.Dir(result.OutputPath))
	if err != nil {
		return fmt.Errorf("output directory is not in a git repository: %w", err)
	}

	g, err := gitops.New(repoRoot, user, token)
	if err != nil {
		return err
	}

	// Create branch
	branchName := config.GitConfig.Branch
	if branchName == "" {
		branchName = fmt.Sprintf("encrypt-%s", result.SecretName)
	}

	if config.GitConfig.CreateBranch || config.GitConfig.Branch == "" {
		fmt.Printf("Creating branch: %s\n", branchName)
		if err := g.CreateBranch(branchName); err != nil {
			return err
		}
	} else {
		fmt.Printf("Checking out branch: %s\n", branchName)
		if err := g.CheckoutBranch(branchName); err != nil {
			return err
		}
	}

	// Stage files
	var filesToAdd []string
	filesToAdd = append(filesToAdd, result.OutputPath)

	// Also stage registry.yaml if it was updated
	registryPath := filepath.Join(repoRoot, "claims", "registry.yaml")
	if _, err := os.Stat(registryPath); err == nil {
		filesToAdd = append(filesToAdd, registryPath)
	}

	fmt.Println("Staging changes...")
	if err := g.AddFiles(filesToAdd); err != nil {
		return err
	}

	// Generate commit message
	message := config.GitConfig.Message
	if message == "" {
		message = generateEncryptCommitMessage(result)
	}

	// Commit
	fmt.Printf("Committing: %s\n", message)
	if err := g.Commit(message, user, ""); err != nil {
		return err
	}
	fmt.Println(successStyle.Render("Committed successfully"))

	// Push
	if config.GitConfig.Push {
		remote := config.GitConfig.Remote
		if remote == "" {
			remote = "origin"
		}

		fmt.Printf("Pushing to %s...\n", remote)
		if err := g.Push(remote, branchName); err != nil {
			return err
		}
		fmt.Println(successStyle.Render("Pushed successfully"))

		// Create PR
		if config.PRConfig != nil && config.PRConfig.Create {
			if err := executeEncryptPRCreation(result, config, repoRoot, branchName); err != nil {
				return fmt.Errorf("creating pull request: %w", err)
			}
		}
	}

	return nil
}

// executeEncryptPRCreation creates a PR for the encrypt operation
func executeEncryptPRCreation(result *EncryptResult, config *EncryptConfig, repoPath, headBranch string) error {
	if err := gitops.CheckGHAuth(); err != nil {
		return err
	}

	title := config.PRConfig.Title
	if title == "" {
		title = fmt.Sprintf("Add encrypted secret: %s", result.SecretName)
	}

	description := config.PRConfig.Description
	if description == "" {
		description = generateEncryptPRDescription(result)
	}

	baseBranch := config.PRConfig.BaseBranch
	if baseBranch == "" {
		baseBranch = "main"
	}

	prConfig := gitops.PRConfig{
		Title:       title,
		Description: description,
		Labels:      config.PRConfig.Labels,
		BaseBranch:  baseBranch,
		HeadBranch:  headBranch,
	}

	fmt.Println("Creating pull request...")
	pr, err := gitops.CreatePR(prConfig, repoPath)
	if err != nil {
		return err
	}

	fmt.Println(successStyle.Render(fmt.Sprintf("Created PR: %s", pr.URL)))
	return nil
}

// generateEncryptCommitMessage creates a commit message for the encrypt operation
func generateEncryptCommitMessage(result *EncryptResult) string {
	return fmt.Sprintf("Add encrypted secret: %s/%s", result.SecretNamespace, result.SecretName)
}

// generateEncryptPRDescription creates a PR description for the encrypt operation
func generateEncryptPRDescription(result *EncryptResult) string {
	var sb strings.Builder

	sb.WriteString("## Summary\n\n")
	fmt.Fprintf(&sb, "Add SOPS-encrypted Kubernetes Secret **%s** in namespace **%s**\n\n", result.SecretName, result.SecretNamespace)
	sb.WriteString("## Details\n\n")
	fmt.Fprintf(&sb, "- Template: `%s`\n", result.TemplateName)
	fmt.Fprintf(&sb, "- Secret name: `%s`\n", result.SecretName)
	fmt.Fprintf(&sb, "- Namespace: `%s`\n", result.SecretNamespace)
	if result.OutputPath != "" {
		fmt.Fprintf(&sb, "- Output: `%s`\n", result.OutputPath)
	}
	sb.WriteString("\n---\n")
	sb.WriteString("*Generated by claims CLI (encrypt)*\n")

	return sb.String()
}

// updateRegistryForEncrypt adds an entry to claims/registry.yaml for the encrypted secret
func updateRegistryForEncrypt(result *EncryptResult, outputDir string) {
	repoRoot, err := findRepoRoot(outputDir)
	if err != nil {
		return // Not in a git repo, skip registry update
	}

	registryPath := filepath.Join(repoRoot, "claims", "registry.yaml")

	// Load or create registry
	reg, err := registry.Load(registryPath)
	if err != nil {
		if !os.IsNotExist(err) {
			return
		}
		reg = registry.NewRegistry()
	}

	// Compute path relative to repo root
	relPath := result.OutputPath
	if result.OutputPath != "" {
		absPath, _ := filepath.Abs(result.OutputPath)
		if rel, err := filepath.Rel(repoRoot, absPath); err == nil {
			relPath = rel
		}
	}

	// Compute category from output directory relative to claims/
	category := ""
	absOutputDir, _ := filepath.Abs(outputDir)
	relOut, err := filepath.Rel(filepath.Join(repoRoot, "claims"), absOutputDir)
	if err == nil && relOut != ".." && !strings.HasPrefix(relOut, "..") {
		parts := strings.SplitN(relOut, string(filepath.Separator), 2)
		if len(parts) > 0 && parts[0] != "." {
			category = parts[0]
		}
	}

	entry := registry.ClaimEntry{
		Name:      result.SecretName,
		Template:  result.TemplateName,
		Category:  category,
		Namespace: result.SecretNamespace,
		CreatedAt: time.Now().UTC().Format(time.RFC3339),
		CreatedBy: "cli-encrypt",
		Source:    "cli-encrypt",
		Path:      relPath,
		Status:    "active",
	}

	registry.AddEntry(reg, entry)

	// Ensure claims directory exists
	if err := os.MkdirAll(filepath.Dir(registryPath), 0755); err != nil {
		return
	}
	if err := registry.Save(registryPath, reg); err != nil {
		fmt.Printf("Warning: could not update registry: %v\n", err)
	}
}
